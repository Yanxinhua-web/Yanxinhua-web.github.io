(window.webpackJsonp=window.webpackJsonp||[]).push([[83],{412:function(e,t,n){"use strict";n.r(t);var o=n(0),r=Object(o.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"正则"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#正则"}},[e._v("#")]),e._v(" 正则")]),e._v(" "),n("h2",{attrs:{id:"正则表达式反向-lookbehind-断言"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#正则表达式反向-lookbehind-断言"}},[e._v("#")]),e._v(" 正则表达式反向(lookbehind)断言")]),e._v(" "),n("p",[e._v("首先我们得先知道什么是断言(Assertion)。\n**断言(Assertion)**是一个对当前匹配位置之前或之后的字符的测试， 它不会实际消耗任何字符，所以断言也被称为“非消耗性匹配”或“非获取匹配”。\n正则表达式的断言一共有 4 种形式：")]),e._v(" "),n("p",[e._v("(?=pattern) 零宽正向肯定断言(zero-width positive lookahead assertion)\n(?!pattern) 零宽正向否定断言(zero-width negative lookahead assertion)\n(?<=pattern) 零宽反向肯定断言(zero-width positive lookbehind assertion)\n(?<!pattern) 零宽反向否定断言(zero-width negative lookbehind assertion)")]),e._v(" "),n("p",[e._v("在ES9之前，JavaScript 正则表达式，只支持正向断言。正向断言的意思是：当前位置后面的字符串应该满足断言，但是并不捕获。例子如下：\n'fishHeadfishTail'.match(/fish(?=Head)/g) // [\"fish\"]\n复制代码反向断言和正向断言的行为一样，只是方向相反。例子如下：\n'abc123'.match(/(?<=(\\d+)(\\d+))$/) //  [\"\", \"1\", \"23\", index: 6, input: \"abc123\", groups: undefined]\n复制代码正则表达式 Unicode 转义\n正则表达式中的Unicode转义符允许根据Unicode字符属性匹配Unicode字符。 它允许区分字符类型，例如大写和小写字母，数学符号和标点符号。\n部分例子代码如下：\n// 匹配所有数字\nconst regex = /^\\p{Number}+$/u;\nregex.test('²³¹¼½¾') // true\nregex.test('㉛㉜㉝') // true\nregex.test('ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫ') // true")]),e._v(" "),n("p",[e._v("// 匹配所有空格\n\\p{White_Space}")]),e._v(" "),n("p",[e._v("// 匹配各种文字的所有字母，等同于 Unicode 版的 \\w\n[\\p{Alphabetic}\\p{Mark}\\p{Decimal_Number}\\p{Connector_Punctuation}\\p{Join_Control}]")]),e._v(" "),n("p",[e._v("// 匹配各种文字的所有非字母的字符，等同于 Unicode 版的 \\W\n[^\\p{Alphabetic}\\p{Mark}\\p{Decimal_Number}\\p{Connector_Punctuation}\\p{Join_Control}]")]),e._v(" "),n("p",[e._v("// 匹配 Emoji\n/\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|\\p{Emoji_Presentation}|\\p{Emoji}\\uFE0F/gu")]),e._v(" "),n("p",[e._v("// 匹配所有的箭头字符\nconst regexArrows = /^\\p{Block=Arrows}+$/u;\nregexArrows.test('←↑→↓↔↕↖↗↘↙⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇧⇩') // true\n复制代码具体的属性列表可查看：developer.mozilla.org/en-US/docs/…\n正则表达式 s/dotAll 模式\n在以往的版本里，JS的正则的.只能匹配emoji跟行终结符以外的所有文本，例如：\nlet regex = /./;")]),e._v(" "),n("p",[e._v("regex.test('\\n');       // false\nregex.test('\\r');       // false\nregex.test('\\u{2028}'); // false\nregex.test('\\u{2029}'); // false")]),e._v(" "),n("p",[e._v("regex.test('\\v');       // true\nregex.test('\\f');       // true\nregex.test('\\u{0085}'); // true")]),e._v(" "),n("p",[e._v("/foo.bar/.test('foo\\nbar');     // false\n/foo[^]bar/.test('foo\\nbar');   // true")]),e._v(" "),n("p",[e._v("/foo.bar/.test('foo\\nbar');     // false\n/foo[\\s]bar/.test('foo\\nbar');   // true\n复制代码但是在ES9之后，JS正则增加了一个新的标志 s 用来表示 dotAll，这可以匹配任意字符。代码如下：\n/foo.bar/s.test('foo\\nbar');    // true")]),e._v(" "),n("p",[e._v("const re = /foo.bar/s;  //  等价于 const re = new RegExp('foo.bar', 's');\nre.test('foo\\nbar');    // true\nre.dotAll;      // true\nre.flags;       // \"s\"\n复制代码正则表达式命名捕获组\n在以往的版本里，JS的正则分组是无法命名的，所以容易混淆。例如下面获取年月日的例子，很容易让人搞不清哪个是月份，哪个是年份:\nconst matched = /(\\d{4})-(\\d{2})-(\\d{2})/.exec('2019-01-01')\nconsole.log(matched[0]);    // 2019-01-01\nconsole.log(matched[1]);    // 2019\nconsole.log(matched[2]);    // 01\nconsole.log(matched[3]);    // 01\n复制代码ES9引入了命名捕获组，允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。代码如下：\nconst RE_DATE = /(?"),n("year",[e._v("\\d{4})-(?"),n("month",[e._v("\\d{2})-(?"),n("day",[e._v("\\d{2})/;")])],1)],1)],1),e._v(" "),n("p",[e._v("const matchObj = RE_DATE.exec('1999-12-31');\nconst year = matchObj.groups.year; // 1999\nconst month = matchObj.groups.month; // 12\nconst day = matchObj.groups.day; // 31")]),e._v(" "),n("p",[e._v("const RE_OPT_A = /^(?"),n("as",[e._v("a+)?$/;\nconst matchObj = RE_OPT_A.exec('');")])],1),e._v(" "),n("p",[e._v("matchObj.groups.as // undefined\n'as' in matchObj.groups // true\n复制代码对象扩展操作符\nES6中添加了数组的扩展操作符，让我们在操作数组时更加简便，美中不足的是并不支持对象扩展操作符，但是在ES9开始，这一功能也得到了支持，例如：\nvar obj1 = { foo: 'bar', x: 42 };\nvar obj2 = { foo: 'baz', y: 13 };")]),e._v(" "),n("p",[e._v('var clonedObj = { ...obj1 };\n// 克隆后的对象: { foo: "bar", x: 42 }')]),e._v(" "),n("p",[e._v('var mergedObj = { ...obj1, ...obj2 };\n// 合并后的对象: { foo: "baz", x: 42, y: 13 }\n复制代码上面便是一个简便的浅拷贝。这里有一点小提示，就是Object.assign() 函数会触发 setters，而展开语法则不会。所以不能替换也不能模拟Object.assign() 。\n如果存在相同的属性名，只有最后一个会生效。')])])}),[],!1,null,null,null);t.default=r.exports}}]);